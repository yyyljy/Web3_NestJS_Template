## CPU 자원 사용량 증가 시

1. 현재 CPU 사용량 확인

    서버의 현재 CPU 사용량 확인
    
    Linux: top, htop, vmstat

2. 높은 CPU 사용률을 유발하는 프로세스 식별

    어떤 애플리케이션이나 서비스가 문제를 일으키는지 파악

    Linux: ps aux --sort=-%cpu

3. 로그 및 모니터링 도구 확인

    애플리케이션 로그와 모니터링 도구를 확인하여 특정 요청이나 작업이 CPU 사용량을 급증시키는지 확인

4. 코드 최적화
    
    비효율적인 알고리즘이나 불필요한 반복문 제거, 데이터베이스 쿼리 최적화.

5. 서버 자원 확인
    
    서버의 하드웨어 자원이 충분한지 확인. CPU 외에도 메모리, 디스크 I/O, 네트워크 대역폭 등의 병목 현상

6. 스케일링
    
    서버 자원이 부족한 경우, 서버 스케일링 고려. 수평 스케일링(서버 추가)이나 수직 스케일링(서버 업그레이드)을 통해 성능 향상

7. 캐싱

    반복적으로 요청되는 데이터를 캐싱. Redis나 Memcached와 같은 캐시 시스템을 활용.

8. 비동기 처리

    비동기 처리를 통해 CPU 사용량 분산. Node.js의 비동기 I/O를 활용하거나, 메시지 큐를 사용.

## Memory 자원 사용량 증가 시

1. 현재 메모리 사용량 확인
    
    서버의 현재 메모리 사용량을 확인.

    Linux: free -m, top, htop 명령어

2. 높은 메모리 사용률을 유발하는 프로세스 식별

    어떤 애플리케이션이나 서비스가 문제를 일으키는지 파악

    Linux: ps aux --sort=-%mem 명령어

3. 로그 및 모니터링 도구 확인

    애플리케이션 로그와 모니터링 도구를 확인하여 특정 요청이나 작업이 메모리 사용량을 급증시키는지 확인

4. 메모리 누수 확인

    코드 리뷰와 프로파일링 도구 사용

5. 캐싱 전략 검토

    Redis나 Memcached와 같은 캐시 시스템을 활용

6. 데이터베이스 쿼리 최적화

    쿼리를 최적화하고, 인덱스 사용하여 성능 향상

7. 서버 자원 확인
    
    서버의 하드웨어 자원이 충분한지 확인. 메모리 외에도 CPU, 디스크 I/O, 네트워크 대역폭 등의 병목 현상

8. 스케일링

    서버를 스케일링 고려. 수평 스케일링(서버 추가)이나 수직 스케일링(서버 업그레이드)

9. 비동기 처리

    비동기 처리를 통해 메모리 사용량을 분산. Node.js의 비동기 I/O, 메시지 큐를 사용하여 작업을 비동기적으로 처리

## DB 문제 발생 위치 확인

1. 쿼리 실행 계획 확인

    쿼리 실행 계획을 통해 병목 현상이 발생하는 부분을 파악

2. 쿼리 프로파일링
  
    쿼리 프로파일링 도구를 사용하여 쿼리의 성능 분석. 쿼리의 각 단계별 실행 시간을 확인.

3. 데이터베이스 로그 확인

    데이터베이스 로그를 확인하여 쿼리 실행 중 발생한 오류나 slow query, 경고 메시지 확인

4. 모니터링 도구 사용

    New Relic, Datadog, AppDynamics 등의 도구를 사용

5. 쿼리 디버깅

    쿼리 디버깅을 통해 쿼리의 각 단계별로 실행 결과를 확인, 문제 발생 위치를 파악. 쿼리를 작은 단위로 나누어 실행.

6. 데이터베이스 상태 확인
    
    데이터베이스의 현재 상태를 확인하여 리소스 사용량, 락(lock) 상태 등을 점검. 특정 쿼리가 시스템 자원을 과도하게 사용하고 있는지 확인.

## DB 쿼리 최적화

1. 인덱스 사용

    자주 조회되는 컬럼에 인덱스를 생성

2. 필요한 컬럼만 선택

    SELECT * 대신 필요한 컬럼만 선택

3. WHERE 절 최적화

    인덱스를 활용할 수 있도록 WHERE 절 조건 작성.
    
    YEAR(date) = 2021 대신 date BETWEEN '2021-01-01' AND '2021-12-31'을 사용.

4. JOIN 최적화

    JOIN은 반드시 필요한 경우에만 사용. 조인되는 컬럼에 인덱스 생성. 또한, INNER JOIN을 우선적으로 사용. OUTER JOIN은 꼭 필요할 때만 사용.

5. 서브쿼리 대신 JOIN 또는 CTE 사용

    서브쿼리 대신 JOIN이나 CTE(Common Table Expressions)를 사용하여 쿼리 성능 향상

6. LIMIT 사용
    
    LIMIT를 사용하여 반환되는 데이터 수를 제한

7. OR 대신 UNION 사용

    OR 조건이 여러 필드를 동시에 비교하여 인덱스를 효율적으로 사용하지 못하는 경우 UNION을 사용하여 쿼리 성능 최적화. UNION을 사용하면 각 쿼리가 별도로 실행되므로 인덱스를 효율적으로 사용. 특히 대규모 데이터셋에서 성능 향상.

8. 캐싱

    Redis나 Memcached와 같은 캐시 시스템 활용

9. 쿼리 계획 분석
    
    데이터베이스의 쿼리 계획을 분석하여 병목 현상 파악